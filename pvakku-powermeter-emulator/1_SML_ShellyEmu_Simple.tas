>D 250
; Einfaches Shelly Emulator Script für ESP8266/ESP32 und Tasmota Image von ottelo
; Emuliert Shelly Pro 3EM für Marstek Akku Jupiter, Venus, B2500, ...
; Anleitung https://ottelo.jimdofree.com/stromz%C3%A4hler-auslesen-tasmota/#13a
; Script basiert auf https://github.com/gemu2015/Sonoff-Tasmota/blob/universal/tasmota/scripting/shelly_emu_script.tas
; Script ist für ein Wifi Tasmota ESP Lesekopf für Stromzähler gedacht, z.B. HichiV1/V2, Bitshake, usw.
; Der Text kann einfach so in den internen Editor von Tasmota eingefügt werden. Beim ESP8266 sollten alle Kommentare entfernen werden.
; Die Marstek App sucht nach dem Shelly via mDNS, der Emulator meldet sich als shellypro3em-<mac>
; Der Datenaustausch erfolgt dann via UDP alle paar Sek (~2-4s beim Jupiter C Plus)
; Zum Test einfach http://IP-TASMOTA/rpc/EMData.GetStatus eingeben
res=0
c1p=0
c2p=0
c3p=0
c1c=0
c2c=0
c3c=0
cpwr=0
kwhin=0
kwhout=0
str=""
tstr=""
mstr1=""
mstr2=""
header=""
once=0
throttle=1
tmp=0


>B
=>sensor53 r


; bei Änderung in >ah muss Tasmota neugestartet werden
>ah
; Shelly
res=won(1 "/rpc/*")
res=won(2 "/status")

>on1
;print Shelly rpc request
str=warg

res=ins(str "EM.GetStatus")
if res>=0 {
wcs so(4)
=#htph
wcs %mstr1%
wcs %header%
=#getstat
wcs %mstr1%
wcs %mstr2%
wcf
break
}
res=ins(str "Shelly.GetDeviceInfo")
if res>=0 {
wcs so(4)
=#htph
wcs %mstr1%	
=#getdefi	
wcs %header%
wcs %mstr1%
wcs %mstr2%
wcf	
break
}
res=ins(str "EM.GetConfig")
if res>=0 {
wcs so(4)
=#htph
wcs %mstr1%	
=#getcfg
wcs %header%
wcs %mstr1%
wcf	
break
}
res=ins(str "EMData.GetStatus")
if res>=0 {
wcs so(4)
=#htph
wcs %mstr1%
=#egetstat
wcs %header%
wcs %mstr1%
wcf
break
}
print unknown http equest: %str%

>on2
;print Shelly status request
wcs so(4)
=#htph
wcs %mstr1%
dp(0 2)
wcs {"Power": %cpwr%,"E_in":%kwhin%,"E_out":%kwhout%}
wcf

#htph
mstr1="HTTP/1.1 200 OK\r\nContent-type: application/json\r\n\r\n"

#getcfg
mstr1="{\"id\":0,\"name\":null,\"blink_mode_selector\":\"active_energy\",\"phase_selector\":\"a\",\"monitor_phase_sequence\":true,\"ct_type\":\"120A\"}}"

#getdefi
mstr1="{\"name\":\""+tstr+"\",\"id\":\""+tstr+"\",\"mac\":\""+maca+"\",\"slot\":1,\"model\":\"SPEM-003CEBEU\","
mstr2="\"gen\":2,\"fw_id\":\"20241011-114455/1.4.4-g6d2a586\","
mstr2+="\"ver\":\"1.4.4\",\"app\":\"Pro3EM\",\"auth_en\":0,\"profile\":\"triphase\"}}"

#getstat
dp(0 2)
mstr1="{\"id\":0,\"a_current\":"+s(c1c)+",\"a_voltage\":230,\"a_act_power\":"+s(c1p)+",\"a_aprt_power\":"+s(c1p)+",\"a_pf\":1,\"a_freq\":50,"
mstr1+="\"b_current\":"+s(c2c)+",\"b_voltage\":230,\"b_act_power\":"+s(c2p)+",\"b_aprt_power\":"+s(c2p)+",\"b_pf\":1,\"b_freq\":50,"
mstr2="\"c_current\":"+s(c3c)+",\"c_voltage\":230,\"c_act_power\":"+s(c3p)+",\"c_aprt_power\":"+s(c3p)+",\"c_pf\":1,\"c_freq\":50,"
mstr2+="\"total_current\":"+s(c1c+c2c+c3c)+",\"total_act_power\":"+s(cpwr)+",\"total_aprt_power\":"+s(cpwr)+"}}"

#egetstat
dp(0 2)
mstr1="{\"id\":0,\"a_total_act_energy\":"+s(c1p)+",\"a_total_act_ret_energy\":"+s(c1p)+",\"b_total_act_energy\":"+s(c2p)+",\"b_total_act_ret_energy\":"+s(c2p)+",\"c_total_act_energy\":"+s(c3p)+",\"c_total_act_ret_energy\":"+s(c3p)+",\"total_act\":"+s(cpwr)+",\"total_act_ret\":"+s(cpwr)+"}}"


>S
; starte MQTT erst wenn der Stromzähler sendet
if (sml[2]>0) {
smlj=1
}
; auf NTP warten
if year<2000 {
break
}

if once==0 {
; starte mDNS damit Marstek den emulierten Shelly findet
res=mdns("shellypro3em-" "-" "shelly")
; start UDP für Datenkommunikation
; Port 1010 oder ggf. 2220 für B2500
res=udp(0 1010)
tstr="shellypro3em-"+maca
header="{\"id\":0,\"src\":\""+tstr+"\",\"result\":"
once=1
}

; Marstek Abfrage verzögern, throttle=1 => sekündlich senden
if upsecs%throttle!=0 {
break;
}

; Peaks reduzieren, verbessert Marstek Regelung
tmp=sml[1]-cpwr
if (tmp>500) {
cpwr=sml[1]-(tmp/2)
} else {
; reduziere die Leistung um 50W, damit die Regelung nicht um 0W, sondern um 50W herum schwingt. Nur sinvoll, wenn PV-Panels direkt am Akku hängen.
;cpwr=sml[1]-50
cpwr=sml[1]
}
; Netzbezug und Einspeisung
kwhin=sml[2]
kwhout=sml[3]

; Standard: Zähler sendet nur Gesamtleistung
c1p=cpwr
; Optional: Wenn Zähler auch Einzelleistungen sendet (L1-3). Marstek prüft dann, auf welcher Phase er verbunden ist. ; entfernen um zu verwenden.
;c1p=sml[4]
;c2p=sml[5]
;c3p=sml[6]
; Ströme berechnen
c1c=c1p/230
;c2c=c2p/230
;c3c=c3p/230


; UDP Anfrage bearbeiten
str=udp(1)
if str!="" {
;print udp rpc payload=%str%
res=ins(str "EM.GetStatus")
if res>=0 {
=#getstat
udp(2 header mstr1 mstr2)
break
}
res=ins(str "Shelly.GetDeviceInfo")
if res>=0 {
=#getdefi
udp(2 header mstr1 mstr2)
break
}
res=ins(str "EM.GetConfig")
if res>=0 {
=#getcfg
udp(2 header mstr1)
break
}
res=ins(str "EMData.GetStatus")
if res>=0 {
=#egetstat
udp(2 header mstr1)
break
}
} else {
; sende auch, wenn Marstek nicht anfragt, verbessert Marstek Regelung
=#getstat
udp(2 header mstr1 mstr2)
}


>W
Uptime{m}%0uptime% min
Leistung an Marstek{m}%0cpwr% W
$<center><span style="font-size:10px;">
$Version 10.09.2025 (ShellyEmuSimple) by ottelo.jimdo.de<br>
$Credits to gemu2015 (Tasmota Script Dev)<br>
$</span></center>


; SML Sektion an euren Stromzähler anpassen
; Anleitung: https://ottelo.jimdofree.com/stromz%C3%A4hler-auslesen-tasmota/#4c
; Reihenfolge nicht ändern: 1=(Gesamt)Leistung sml[1] 2=Verbrauch sml[2] 3=Einspeisung sml[3]
; Medianfilter <flag> = 16 nicht verwenden, verbessert Marstek Regelung
; https://tasmota.github.io/docs/Smart-Meter-Interface/#meter-definition
>M 1
; Beispiel MT175 mit HichiV2
+1,3,s,0,9600,MT175,1
1,77070100100700ff@1,Leistung,W,Power_curr,0
1,77070100010800ff@1000,Verbrauch,KWh,Total_in,2
1,77070100020800ff@1000,Einspeisung,KWh,Total_out,2
;optional - Falls die Leistung aller 3 Phasen ausgegeben wird, optional relevant für Shelly Emulation sml[4],[5],[6]
;1,77070100240700ff@1,L1,W,L1,0
;1,77070100380700ff@1,L2,W,L2,0
;1,770701004C0700ff@1,L3,W,L3,0
#