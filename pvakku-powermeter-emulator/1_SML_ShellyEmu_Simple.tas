>D 250
; Einfaches Shelly Emulator Script für ESP32 und Tasmota Image (ab V15.1.0) von ottelo
; Emuliert Shelly Pro 3EM für Marstek Akku Jupiter, Venus, B2500
; Anleitung https://ottelo.jimdofree.com/stromz%C3%A4hler-auslesen-tasmota/#13a
; Script basiert auf https://github.com/gemu2015/Sonoff-Tasmota/blob/universal/tasmota/scripting/shelly_emu_script.tas
; Script ist für ein Wifi Tasmota ESP Lesekopf für Stromzähler gedacht, z.B. HichiV2 (nicht V1), Bitshake, usw.
; Der Text kann einfach so in den internen Editor von Tasmota eingefügt werden.
; Die Marstek App sucht nach dem Shelly via mDNS, der Emulator meldet sich als shellypro3em-<mac>
; Der Datenaustausch erfolgt dann via UDP alle paar Sek (~2-4s beim Jupiter C Plus)

; PermVars (max:1536bytes=384vars)
p:dval=0
p:dval2=0
p:mval2=0
p:mval=0
p:yval=0
p:yval2=0
p:rxind=1
p:txind=1
p:sel=0
p:pwroffset=0
p:pwrforce=0
p:throttle=1
p:port=1
t:t1=60
rxpin=0
txpin=0
hr=0
;-- SHELLY EMULATION --
res=0
tmp=0
c1p=0
c2p=0
c3p=0
c1c=0
c2c=0
c3c=0
cpwr=0
str=""
mstr1=""
mstr2=""
header=""
once=0


>B
sota("")
rxpin=rxind-1
txpin=txind-1
->sensor53 r
smlj=0
header="{\"id\":0,\"src\":\"shellypro3em-"+maca+"\",\"result\":"
throttle=mp(throttle <1 1 >60 60)
pwroffset=mp(pwroffset <-200 -200 >200 200)

#save
svars

#init
dval=sml[2]
dval2=sml[3]
mval=sml[2]
mval2=sml[3]
yval=sml[2]
yval2=sml[3]
->Backlog2 Timezone 99;TimeStd 0,0,10,1,3,60;TimeDst 0,0,3,1,2,120
=#save

;-- SHELLY EMULATION --
#getstat
;B2500 benötigt unbedingt 2 Dezimalstellen
dp(0 2)
mstr1="{\"id\":0,\"a_current\":"+s(c1c)+",\"a_voltage\":230,\"a_act_power\":"+s(c1p)+",\"a_aprt_power\":"+s(c1p)+",\"a_pf\":1,\"a_freq\":50,"
mstr1+="\"b_current\":"+s(c2c)+",\"b_voltage\":230,\"b_act_power\":"+s(c2p)+",\"b_aprt_power\":"+s(c2p)+",\"b_pf\":1,\"b_freq\":50,"
mstr2="\"c_current\":"+s(c3c)+",\"c_voltage\":230,\"c_act_power\":"+s(c3p)+",\"c_aprt_power\":"+s(c3p)+",\"c_pf\":1,\"c_freq\":50,"
mstr2+="\"total_current\":"+s(c1c+c2c+c3c)+",\"total_act_power\":"+s(cpwr)+",\"total_aprt_power\":"+s(cpwr)+"}}"

>C
if eres==1 {
->sensor53 r
svars
eres=0
}

>F
fe("sml_ftask.tas")
;-- SHELLY EMULATION --
; UDP Anfrage beantworten
str=udp(1)
if (str!="") {
;print udp rpc payload=%str%
res=ins(str "EM.GetStatus")
if (res>=0) {
=#getstat
udp(2 header mstr1 mstr2)
}
} else {
; Optional: Sende auch, wenn Marstek nicht anfragt, verbessert Marstek Regelung
if (pwrforce>0) {
=#getstat
udp(2 header mstr1 mstr2)
}
}

>S
fe("sml_stask.tas")
; Pinauswahl
if ((chg[rxind]>0) or (chg[txind]>0)) {
rxpin=rxind-1
->sensor53 r
=#save
}
; Warte auf NTP und Zähler
if ((year<2020) or (sml[2]==0)) {
print auf NTP/Zähler warten
break
}
; Starte MQTT erst wenn Daten vom Stromzähler kommen
smlj=1

; alle 60s
if (t1==0) {
t1=60
hr=hours
; Tages-, Monats-, Jahresverbrauch um Mitternacht
; Aktualisiere & speichere Zählerstände
if ((chg[hr]>0) and (hr==0)) {
; Tageswechsel
dval=sml[2]
dval2=sml[3]
if (day==1) {
; Monatswechsel
mval=sml[2]
mval2=sml[3]
}
if (day*month==1) {
; Jahreswechsel
yval=sml[2]
yval2=sml[3]
}
; nur 1x um Mitternacht speichern
=#save
}
}

;-- SHELLY EMULATION --
if (once==0) {
; starte mDNS damit Marstek den emulierten Shelly findet
mdns("shellypro3em-" "-" "shelly")
; start UDP für Datenkommunikation
; Port 1010 oder ggf. 2220 für B2500
if (port==2) {
udp(0 2220)
} else {
udp(0 1010)
}
once=1
}

; Werte nur alle x Sek updaten (throttle=1 => sekündlich)
if (upsecs%throttle==0) {
; Peaks reduzieren, verbessert Regelung
tmp=sml[1]-cpwr
if (tmp>500) {
cpwr=sml[1]-(tmp/2)
} else {
; Nulleinspeisung-Offset: reduziere die Leistung damit die Regelung nicht um 0W herum schwingt. Nur sinvoll, wenn PV-Panels direkt am Akku hängen.
cpwr=sml[1]-pwroffset
}

; Standard: Zähler sendet nur Gesamtleistung
c1p=cpwr
; Optional: Wenn Zähler auch Einzelleistungen sendet (L1-3). Marstek prüft dann, auf welcher Phase er verbunden ist. ; entfernen um zu verwenden.
;c1p=sml[4]
;c2p=sml[5]
;c3p=sml[6]
; Ströme berechnen
c1c=c1p/230
;c2c=c2p/230
;c3c=c3p/230
}

>W
Leistung (an Marstek Akku){m}%0cpwr% W
Tagesverbrauch{m}%2(sml[2]-dval)% kWh
Monatsverbrauch{m}%2(sml[2]-mval)% kWh
Jahresverbrauch{m}%2(sml[2]-yval)% kWh
Tageseinspeisung{m}%2(sml[3]-dval2)% kWh
Monatseinspeisung{m}%2(sml[3]-mval2)% kWh
Jahreseinspeisung{m}%2(sml[3]-yval2)% kWh
Uptime{m}%0(int(uptime/1440))% d %0(int((uptime%1440)/60))% h %0(uptime%60)% min
$<center><span style="font-size:10px;">
$Version 26.01.2026 (ShellyEmuSimple) by ottelo.jimdo.de<br>
$und gemu2015 (ScriptEngine V%vers%)<br>
$Hinweis: Alle Werte werden um Mitternacht gespeichert!<br>
$</span></center>


>w &#x2699;&#xFE0F; Stromzähler / Daten / Akku
<button onclick="history.back()">&#x2B05;&#xFE0F; Zurück</button>
<hr>
<style>
.flex-container{
display:flex;
justify-content:center;
}
.center-flex-horizontally{
width:270px;
background-color:#f0f0f0;
text-align:left;
padding:20px;
border:2px solid #ccc;
}
</style>
so(17+4)
<div class="flex-container">
<div class="center-flex-horizontally">  
<style>.button-group{display:flex;flex-direction:column;align-items:flex-start;gap:10px;}</style>
<div class=button-group>
<b>&#x1F4C4; 1_SML_ShellyEmu_Simple</b>
<button type="submit" onclick="if(confirm('Tages/Monats/Jahreswerte zurücksetzen?')){seva(1,'_init');}">&#x1F504; Zählerwerte initialisieren</button>
<button type="button" onclick="seva(1,'_save');alert('Daten wurden gespeichert!');">&#x1F4BE; Daten speichern</button></div>
<hr>
<b>&#x1F50B; Akku</b><br><br>
Offset für Nulleinspeisung [W]:
nm(-200 200 1 pwroffset "" 50 0)
Update der Werte verzögern [s]:
nm(1 60 1 throttle "" 50 0)
UDP-Port (Neustart notwendig):
rb(port "" "1010" "2220")
Datenübertragung erzwingen:
ck(pwrforce "")
<hr>
<b>&#x26A1; Stromzähler</b><br>
smlpd("https://raw.githubusercontent.com/ottelo9/tasmota-sml-script/main/script-list-menu/meters" "Stromzählerauswahl (<a href=https://ottelo.jimdofree.com/kontakt>Probleme?)</a><br>" sel)
pd(rxind "RX Pin: " 50 "#gr")
pd(txind "TX Pin: " 50 "#gr")
<span style="font-size:9px">
RX=3 TX=1: Hichi, Stromleser, LesekopfV32, Wattwächter<br>
RX=5 TX=4: bitShake<br></span>
<br>
&#x1F4DD; <a href="/ufse?file=/sml_meter.def">Stromzähler Script</a>
</div>
</div>


; >M SMARTMETER DESCRIPTOR / ZÄHLER AUSWAHL AB 01.12.2025 VIA DROP-DOWN MENÜ:
; gewählter Zähler wird in Tools > Manage Filesystem > sml_meter.def geladen
; TASMOTA (ottelo) IMAGE ab v15.1.0 (07.12.2025) NOTWENDIG
; ODER >M SEKTION MANUELL HINZUFÜGEN ODER sml_deter.def EDITIEREN

; EXTRA HINWEISE FÜR SHELLY EMULATION:
; Editiert die "sml_meter.def" (liegt unter Tools > Manage Filesystem, wenn ihr einen Zähler via DropDown gewählt habt)
; Sucht die >M 1 Sektion. Direkt darunter ist der SML Descriptor und sieht z.B. so aus:
; +1,%0rxpin%,s,16,9600,MT175,%0txpin%
; Standardmäßig ist der Medianfilter "16" aktiviert, diesen solltet ihr auf 0 ändern, verbessert Regelung
; https://tasmota.github.io/docs/Smart-Meter-Interface/#meter-definition
