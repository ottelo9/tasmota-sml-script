>D 250
; Einfaches Shelly Emulator Script für ESP8266/ESP32 und Tasmota Image von ottelo
; Emuliert Shelly Pro 3EM für Marstek Akku Jupiter, Venus, B2500
; Scriptgröße beim ESP8266 begrenzt: EEP_SCRIPT_SIZE 4096
; Anleitung https://ottelo.jimdofree.com/stromz%C3%A4hler-auslesen-tasmota/#13a
; Script basiert auf https://github.com/gemu2015/Sonoff-Tasmota/blob/universal/tasmota/scripting/shelly_emu_script.tas
; Script ist für ein Wifi Tasmota ESP Lesekopf für Stromzähler gedacht, z.B. HichiV1/V2, Bitshake, usw.
; Der Text kann einfach so in den internen Editor von Tasmota eingefügt werden. Beim ESP8266 sollten alle Kommentare entfernen werden.
; Die Marstek App sucht nach dem Shelly via mDNS, der Emulator meldet sich als shellypro3em-<mac>
; Der Datenaustausch erfolgt dann via UDP alle paar Sek (~2-4s beim Jupiter C Plus)

; Zum erstmaligen Einrichten des Scripts folgendes in die Console eingeben (erst wenn auch Werte vom Zähler kommen!)
;script>=#init

; PermVars (max:1536bytes=384vars): Tages, Monats, Jahres Verbrauch / Einspeisung
p:dval=0
p:dval2=0
p:mval2=0
p:mval=0
p:yval=0
p:yval2=0
t:t1=60
tmp=0
save=0
hr=0
;-- SHELLY EMULATION --
res=0
c1p=0
c2p=0
c3p=0
c1c=0
c2c=0
c3c=0
cpwr=0
str=""
mstr1=""
mstr2=""
header=""
once=0
throttle=1


>B
=>sensor53 r
smlj=0
header="{\"id\":0,\"src\":\"shellypro3em-"+maca+"\",\"result\":"

#init
dval=sml[2]
dval2=sml[3]
mval=sml[2]
mval2=sml[3]
yval=sml[2]
yval2=sml[3]
->Backlog2 otaurl KEIN OTA UPGRADE VIA WEBSERVER!
->Backlog2 Timezone 99;TimeStd 0,0,10,1,3,60;TimeDst 0,0,3,1,2,120
svars

;-- SHELLY EMULATION --
#getstat
;B2500 benötigt unbedingt 2 Dezimalstellen
dp(0 2)
mstr1="{\"id\":0,\"a_current\":"+s(c1c)+",\"a_voltage\":230,\"a_act_power\":"+s(c1p)+",\"a_aprt_power\":"+s(c1p)+",\"a_pf\":1,\"a_freq\":50,"
mstr1+="\"b_current\":"+s(c2c)+",\"b_voltage\":230,\"b_act_power\":"+s(c2p)+",\"b_aprt_power\":"+s(c2p)+",\"b_pf\":1,\"b_freq\":50,"
mstr2="\"c_current\":"+s(c3c)+",\"c_voltage\":230,\"c_act_power\":"+s(c3p)+",\"c_aprt_power\":"+s(c3p)+",\"c_pf\":1,\"c_freq\":50,"
mstr2+="\"total_current\":"+s(c1c+c2c+c3c)+",\"total_act_power\":"+s(cpwr)+",\"total_aprt_power\":"+s(cpwr)+"}}"


>S
if (save==1) {
save=0
svars
}
; Warte auf NTP und Zähler
if ((year<2020) or (sml[2]==0)) {
print auf NTP/Zähler warten
break
}
; Starte MQTT erst wenn Daten vom Stromzähler kommen
smlj=1

; alle 60s
if (t1==0) {
t1=60
hr=hours
; Tages-, Monats-, Jahresverbrauch um Mitternacht
; Aktualisiere & speichere Zählerstände
if ((chg[hr]>0) and (hr==0)) {
; Tageswechsel
dval=sml[2]
dval2=sml[3]
if (day==1) {
; Monatswechsel
mval=sml[2]
mval2=sml[3]
}
if (day*month==1) {
; Jahreswechsel
yval=sml[2]
yval2=sml[3]
}
; nur 1x um Mitternacht speichern
svars
}
}

;-- SHELLY EMULATION --
if (once==0) {
; starte mDNS damit Marstek den emulierten Shelly findet
res=mdns("shellypro3em-" "-" "shelly")
; start UDP für Datenkommunikation
; Port 1010 oder ggf. 2220 für B2500
res=udp(0 1010)
once=1
}

; Marstek Abfrage verzögern, throttle=1 => sekündlich senden
if (upsecs%throttle!=0) {
break;
}

; Peaks reduzieren, verbessert Regelung
tmp=sml[1]-cpwr
if (tmp>500) {
cpwr=sml[1]-(tmp/2)
} else {
; reduziere die Leistung um 50W, damit die Regelung nicht um 0W, sondern um 50W herum schwingt. Nur sinvoll, wenn PV-Panels direkt am Akku hängen.
;cpwr=sml[1]-50
cpwr=sml[1]
}

; Standard: Zähler sendet nur Gesamtleistung
c1p=cpwr
; Optional: Wenn Zähler auch Einzelleistungen sendet (L1-3). Marstek prüft dann, auf welcher Phase er verbunden ist. ; entfernen um zu verwenden.
;c1p=sml[4]
;c2p=sml[5]
;c3p=sml[6]
; Ströme berechnen
c1c=c1p/230
;c2c=c2p/230
;c3c=c3p/230

; UDP Anfrage bearbeiten
str=udp(1)
if (str!="") {
;print udp rpc payload=%str%
res=ins(str "EM.GetStatus")
if (res>=0) {
=#getstat
udp(2 header mstr1 mstr2)
break
}
} else {
; Optional: Sende auch, wenn Marstek nicht anfragt, verbessert Marstek Regelung
;=#getstat
;udp(2 header mstr1 mstr2)
}


>W
bu(save "gespeichert!" "Daten sofort speichern")
Leistung (an Marstek Akku){m}%0cpwr% W
Tagesverbrauch{m}%2(sml[2]-dval)% kWh
Monatsverbrauch{m}%2(sml[2]-mval)% kWh
Jahresverbrauch{m}%2(sml[2]-yval)% kWh
Tageseinspeisung{m}%2(sml[3]-dval2)% kWh
Monatseinspeisung{m}%2(sml[3]-mval2)% kWh
Jahreseinspeisung{m}%2(sml[3]-yval2)% kWh
Uptime{m}%0uptime% min
$<center><span style="font-size:10px;">
$Version 02.10.2025 (ShellyEmuSimple) by ottelo.jimdo.de<br>
$Credits to gemu2015 (Tasmota Script Dev)<br>
$</span></center>


; SML Sektion an euren Stromzähler anpassen
; Anleitung: https://ottelo.jimdofree.com/stromz%C3%A4hler-auslesen-tasmota/#4c
; Reihenfolge nicht ändern: 1=(Gesamt)Leistung sml[1] 2=Verbrauch sml[2] 3=Einspeisung sml[3]
; Medianfilter <flag> = 16 nicht verwenden, verbessert Marstek Regelung
; https://tasmota.github.io/docs/Smart-Meter-Interface/#meter-definition
>M 1
; Beispiel MT175 mit HichiV1/V2
+1,3,s,0,9600,MT175,1
1,77070100100700ff@1,Leistung,W,Power_curr,0
1,77070100010800ff@1000,Verbrauch,KWh,Total_in,2
1,77070100020800ff@1000,Einspeisung,KWh,Total_out,2
;optional - Falls die Leistung aller 3 Phasen ausgegeben wird, optional relevant für Shelly Emulation sml[4],[5],[6]
;1,77070100240700ff@1,L1,W,L1,0
;1,77070100380700ff@1,L2,W,L2,0
;1,770701004C0700ff@1,L3,W,L3,0
#